using Microsoft.CodeAnalysis;

namespace DotNetLab;

// RS1041: Compiler extensions should be implemented in assemblies targeting netstandard2.0
// We are fine with only supporting .NET Core compiler hosts.
#pragma warning disable RS1041

[Generator(LanguageNames.CSharp)]
public sealed class TemplateCacheGenerator : IIncrementalGenerator
{
    private static readonly Func<AdditionalText, string> readFile = static (file) => file.GetText()!.ToString();

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        const string jsonExtension = ".json";
        const string txtExtension = ".txt";

        var txtFiles = context.AdditionalTextsProvider
            .Where(static text => text.Path.EndsWith(txtExtension, StringComparison.OrdinalIgnoreCase))
            .Collect();

        var jsonFiles = context.AdditionalTextsProvider
            .Where(static text => text.Path.EndsWith(jsonExtension, StringComparison.OrdinalIgnoreCase));

        var snapshots = jsonFiles
            .Combine(txtFiles)
            .Select(static (t, ct) =>
            {
                var (jsonFile, txtFiles) = t;
                var fileName = Path.GetFileName(jsonFile.Path);
                var name = fileName[..^jsonExtension.Length];
                var prefix = $"{name}.";
                ImmutableArray<(AdditionalText Text, string FileName)> result =
                [
                    (jsonFile, fileName),
                    .. txtFiles
                        .Select(static t => (Text: t, FileName: Path.GetFileName(t.Path)))
                        .Where(t => t.FileName.StartsWith(prefix, StringComparison.OrdinalIgnoreCase)),
                ];
                var comparable = new Comparable<ImmutableArray<(AdditionalText Text, string FileName)>, Comparers.ImmutableArray<(AdditionalText Text, string FileName), Comparers.Default<(AdditionalText Text, string FileName)>>> (result);
                return (Name: name, Files: comparable);
            })
            .Select(static (t, ct) =>
            {
                return Snapshot.LoadFromFiles(t.Name, t.Files.Value.Select(t => (
                    File: t.Text,
                    t.FileName,
                    Content: readFile)));
            });

        context.RegisterSourceOutput(snapshots, static (ctx, snapshot) =>
        {
            ctx.AddSource($"{snapshot.Name}.g.cs", $$""""
                // <auto-generated/>

                #nullable enable

                namespace DotNetLab.Lab;

                partial class TemplateCache
                {
                    private static global::System.ReadOnlySpan<byte> Get{{snapshot.Name}}() => """
                        {{snapshot.ToJson().ToJsonString()}}
                        """u8;
                }
                """");
        });
    }
}
